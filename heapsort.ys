#
# Calling conventions:
#     %rdi, %rsi, %rdx, %rcx, %r8, %r9, %r10, %r11 and %rax are caller saved
#     %rbx, %rbp, %r12, %r13, %r14 are callee saved
#     %rsp can not be used except for its normal use as a stack pointer.
#     argument are passed through registers %rdi, %rsi, %rdx in this order.
#     values are returned through %rax
#
.pos 0x100

main:	
	xorq   %rdi, %rdi        # %rdi = 0
	irmovq bottom,  %rsp     # initialize stack
	mrmovq size(%rdi), %rdi  # %rdi = size
	call   heapsort
	halt

#
# get_element
#     %rdi: element index
# returns:
#     %rax: the element

get_element:
#	addq   %rdi, %rdi
#	addq   %rdi, %rdi
#	addq   %rdi, %rdi

    irmovq $8, %r8
    mulq %r8, %rdi

	mrmovq heap(%rdi), %rax
	ret
	
#
# put_element
#     %rdi: element index
#     %rsi: element

put_element:
#	addq   %rdi, %rdi
#	addq   %rdi, %rdi
#	addq   %rdi, %rdi

    irmovq $8, %rax
    mulq %rax, %rdi
    
	rmmovq %rsi, heap(%rdi)
	ret

#
# Swap:
#    %rdi: index1
#    %rsi: index2
#
swap:
	
	# call   get_element      # tmp = heap[index1]
	irmovq $8, %r8
    mulq %r8, %rdi          # rdi = i1
    mulq %r8, %rsi          # rsi = i2

	mrmovq heap(%rdi), %r10 #.  r10 = heap[i1]
	mrmovq heap(%rsi), %r11  #  r11 = heap[i2]

    rmmovq %r11, heap(%rdi)
    rmmovq %r10, heap(%rsi)

	ret

#
# Check_child
#     %rdi: child index
#     %rsi: index of highest
#     %rdx: last
# Returns:
#     %rax: true if child <= last && heap[highest] < heap[child]
#
check_child:
	rrmovq %rdi, %r11       # if child <= last, we can continue
	subq   %rdx, %r11
	jg     check_child_end

    irmovq $8, %r8
	rrmovq %rsi, %r11      # get heap[highest]
    irmovq $1, %rdx
    xorq %rax, %rax
    
    mulq %r8, %rdi
    mulq %r8, %r11

	mrmovq heap(%rdi), %rcx
	mrmovq heap(%r11), %r11    

	subq   %r11, %rcx      # if heap[child] > heap[highest], return 1
	cmovg  %rdx, %rax
	ret

check_child_end:
	xorq %rax, %rax
	ret

#
# Heapify_node
#     %rdi: index
#     %rsi: last
#
# Local variables:
#     %rbx: index
#     %r12: highest
#     %r13: last
#     %r8 : 8
#     %rdx: 1
heapify_node:
	pushq  %rbx             # Save %rbx and use it to store index
	pushq  %r12
	pushq  %r13
	rrmovq %rdi, %r12       # %r12 = highest
	rrmovq %rsi, %r13       # %r13 = last
	rrmovq %rdi, %rbx
	irmovq $8,   %r8
	irmovq $1,   %rdx

heapify_loop:
	rrmovq %rbx, %rdi       # left_child = 2 * index + 1
	addq   %rdi, %rdi

	addq   %rdx,  %rdi
	rrmovq %r12, %rsi

	pushq  %rdi             # save this as we'll need it after the call
	#call   check_child
check_child0:
	rrmovq %rdi, %r11       # if child <= last, we can continue
	subq   %r13, %r11
	jg     check_child_end0

	rrmovq %rsi, %r11      # get heap[highest]
    xorq %rax, %rax
    
    mulq %r8, %rdi
    mulq %r8, %r11

	mrmovq heap(%rdi), %rcx
	mrmovq heap(%r11), %r11    

	subq   %r11, %rcx      # if heap[child] > heap[highest], return 1
	cmovg  %rdx, %rax
	jmp check_child_ret0

check_child_end0:
	xorq %rax, %rax
	
check_child_ret0:
	popq   %rdi
	
	andq   %rax, %rax
	cmovne %rdi, %r12  

	rrmovq %rbx, %rdi       # right_child = 2 * index + 2
	addq   %rdx, %rdi
	addq   %rdi, %rdi

	rrmovq %r12, %rsi

	pushq  %rdi             # save this as we'll need it after the call
#	call   check_child
check_child1:
	rrmovq %rdi, %r11       # if child <= last, we can continue
	subq   %r13, %r11
	jg     check_child_end1

	rrmovq %rsi, %r11      # get heap[highest]
    xorq %rax, %rax
    
    mulq %r8, %rdi
    mulq %r8, %r11

	mrmovq heap(%rdi), %rcx
	mrmovq heap(%r11), %r11    

	subq   %r11, %rcx      # if heap[child] > heap[highest], return 1
	cmovg  %rdx, %rax
	jmp check_child_ret1

check_child_end1:
	xorq %rax, %rax
	
check_child_ret1:
	popq  %rdi
	andq   %rax, %rax
	cmovne %rdi, %r12

	rrmovq %r12, %rdi
	subq   %rbx, %rdi
	je     heapify_end

	rrmovq %r12, %rdi
	rrmovq %rbx, %rsi
	


	#call   swap
    mulq %r8, %rdi          # rdi = i1
    mulq %r8, %rsi          # rsi = i2

	mrmovq heap(%rdi), %r10 #.  r10 = heap[i1]
	mrmovq heap(%rsi), %r11  #  r11 = heap[i2]

    rmmovq %r11, heap(%rdi)
    rmmovq %r10, heap(%rsi)


	rrmovq %r12, %rbx
	jmp    heapify_loop

heapify_end:
	popq   %r13
	popq   %r12
	popq   %rbx
	ret

#
# Heapify_array
#     %rdi: last
#
heapify_array:
	rrmovq %rdi, %r10		# store last in %r10

	irmovq $1, %rsi		# %rdi = last - 1
	subq   %rsi, %rdi
	irmovq $2, %rsi		# %rdi = (last - 1)/2
	divq   %rsi, %rdi
	rrmovq %rdi, %r9       # i = %rdi
	
ha_loop:
	andq   %r9, %r9       # check if i < 0
	jl     ha_ret
	
	rrmovq %r9, %rdi       # Set %rdi = i, %rsi = last      
	rrmovq %r10, %rsi
	call   heapify_node     # Heapify the node
	
	irmovq $1, %rdi         # i--
	subq   %rdi, %r9
	jmp    ha_loop

ha_ret:
    ret
	
	
#
# Extract_max
#     %rdi: last
#
extract_max:
	pushq  %rbx		# Save %rax before using it for max
    pushq  %rdi             # Save this as we'll need it later
	
	xorq   %rdi, %rdi       # max = heap[0]
    irmovq $8, %rax
    mulq %rax, %rdi

	mrmovq heap(%rdi), %rbx

	mrmovq 0(%rsp), %rdi    # Recover %rdi, but leave it on the stack too.
    mulq %rax, %rdi

	mrmovq heap(%rdi), %rax

	xorq   %rdi, %rdi
	rmmovq %rax, heap(%rdi)

	popq   %rdi
	rrmovq %rdi, %rsi	# %rsi = last - 1
	irmovq $1, %rcx
	subq   %rcx, %rsi
	xorq   %rdi, %rdi       # %rdi = 0
	call   heapify_node     # Heapify the root

	rrmovq %rbx, %rax       # Set return value to max
	popq   %rbx
	ret

#
# Heapsort
#    %rdi: Number of entries in the array
#
heapsort:
	irmovq 1, %rsi
	pushq  %rbx

	subq   %rsi, %rdi	# %rdi is now the index of the last element
	jle    hs_ret		# If there were 1 or 0 entries, we are done
	rrmovq %rdi, %rbx       # %rbx (i) = last
	call   heapify_array    # heapify_array(last)

hs_loop:
	andq   %rbx, %rbx
    jl     hs_ret
    
    rrmovq %rbx, %rdi       # max = extract_max(i)
	call   extract_max
	rrmovq %rbx, %rsi       # heap[i] = max
	
	irmovq $8, %r11
	mulq   %r11, %rsi
    rmmovq %rax, heap(%rsi)
    
    irmovq $1, %rdi         # i--
	subq   %rdi, %rbx
	jmp    hs_loop
    
hs_ret:	
    popq   %rbx
	ret


#
# Array to sort
#
.pos 0x1000
heap:	
	.quad	0x5efa0
	.quad	0xc2764
	.quad	0xb2a00
	.quad	0xf45e3
	.quad	0x9554c

size:   .quad 5
	
#
# Stack (32 thirty-two bit words is more than enough here).
#
.pos 0x3000
top:	            .quad 0x00000000		# top of stack.
                    .quad 0x00000000
                    .quad 0x00000000
                    .quad 0x00000000
                    .quad 0x00000000
                    .quad 0x00000000
                    .quad 0x00000000
                    .quad 0x00000000
                    .quad 0x00000000
                    .quad 0x00000000
                    .quad 0x00000000
                    .quad 0x00000000
                    .quad 0x00000000
                    .quad 0x00000000
                    .quad 0x00000000
                    .quad 0x00000000
                    .quad 0x00000000
                    .quad 0x00000000
                    .quad 0x00000000
                    .quad 0x00000000
bottom:             .quad 0x00000000		# bottom of stack.
